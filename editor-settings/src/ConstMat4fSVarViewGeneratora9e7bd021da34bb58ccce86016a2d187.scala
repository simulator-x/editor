//AutoGenerated Begin
//DO NOT EDIT!
package simx.components.editor.gui

import java.awt.{RenderingHints, Color, Graphics2D}
import javax.swing.{JComponent, InputVerifier}

import simplex3d.math.{ConstVec3i, ConstVec2i, Vec2i}

import scala.reflect.ClassTag
import scala.swing._
import simplex3d.math.floatx.{Vec3f, ConstVec3f, ConstMat4f}


class ConstMat4fSVarViewGeneratora9e7bd021da34bb58ccce86016a2d187 extends SVarViewGenerator[ConstMat4f] {

  def generate: SVarView[ConstMat4f] = new SVarView[ConstMat4f] {

//AutoGenerated END
//Put your code below

    val MAX_HISTORY = 60
    var data: Option[ConstMat4f] = None
    val _s = 200
    val center = ConstVec2i(_s/2,_s/2)
    val colorStep = ConstVec3i(255/MAX_HISTORY)



    val dataPanel = new Label {

      minimumSize = new Dimension(_s, _s)
      preferredSize = new Dimension(_s, _s)
      maximumSize = new Dimension(_s, _s)

      override def paint(g: Graphics2D) {
        super.paint(g)

        g.setColor(Color.white)
        g.fillRect(0, 0, _s, _s)

        g.setColor(Color.RED)
        g.drawArc(0,0,_s,_s,0, 360)

        //var last: Option[ConstVec2i] = None
        var color = ConstVec3i(0,0,0)
        val s = scale.text.toFloat
        //        println(data)

        def projectOnPlane(u: ConstVec3f, n: ConstVec3f) = {
          import simplex3d.math.float.functions._
          u - (n * dot(normalize(u), normalize(n)))

        }

        data.foreach{ d =>
          val x = d(0).xyz
          val y = d(1).xyz
          val z = d(2).xyz

          if(xBtn.selected) {
            val normal = Vec3f.UnitX
            var yp = ConstVec2i(projectOnPlane(y, normal).yz * s)
            var zp = ConstVec2i(projectOnPlane(z, normal).yz * s)
            yp = ConstVec2i(yp.x, -yp.y)
			zp = ConstVec2i(zp.x, -zp.y)
			yp = center + yp
            zp = center + zp
            g.setColor(new Color(0,255,0))
            g.drawLine(center.x, center.y, yp.x, yp.y)
            g.setColor(new Color(0,0,255))
            g.drawLine(center.x, center.y, zp.x, zp.y)
          } else if(yBtn.selected) {
            val normal = Vec3f.UnitY
            var xp = ConstVec2i(projectOnPlane(x, normal).xz * s)
            var zp = ConstVec2i(projectOnPlane(z, normal).xz * s)
			xp = ConstVec2i(xp.x, -xp.y)
			zp = ConstVec2i(zp.x, -zp.y)
			xp = center + xp
            zp = center + zp
            g.setColor(new Color(255,0,0))
            g.drawLine(center.x, center.y, xp.x, xp.y)
            g.setColor(new Color(0,0,255))
            g.drawLine(center.x, center.y, zp.x, zp.y)
          } else {
            val normal = Vec3f.UnitZ
            var xp = ConstVec2i(projectOnPlane(x, normal).xy * s)
            var yp = ConstVec2i(projectOnPlane(y, normal).xy * s)
            xp = ConstVec2i(xp.x, -xp.y)
			yp = ConstVec2i(yp.x, -yp.y)
			xp = center + xp
            yp = center + yp
            g.setColor(new Color(255,0,0))
            g.drawLine(center.x, center.y, xp.x, xp.y)
            g.setColor(new Color(0,255,0))
            g.drawLine(center.x, center.y, yp.x, yp.y)
          }

        }

      }
    }

    val xBtn = new RadioButton("x")
    val yBtn = new RadioButton("y")
    val zBtn = new RadioButton("z") {
      selected = true
    }

    val scale = new TextField("100") {
      val placeholder = "scale"

      peer.setInputVerifier(new InputVerifier {
        override def verify(input: JComponent) = {
          try {
            text.toFloat
            opaque = false
            background = Color.white
            true
          } catch { case e: Throwable =>
            opaque = true
            background = Color.red
            false
          }
        }
      })

      protected override def paintComponent(pG: Graphics2D) {
        super.paintComponent(pG)
        if (placeholder.length == 0 || text.length > 0) {
          return
        }
        val g: Graphics2D = pG.asInstanceOf[Graphics2D]
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)
        g.setColor(Color.GRAY)
        g.drawString(placeholder, peer.getInsets.left, pG.getFontMetrics.getMaxAscent + peer.getInsets.top)
      }
    }

    val btnGroup = new ButtonGroup(xBtn, yBtn, zBtn)
    val settingsLayout = new GridPanel(4,1) {
      contents += xBtn
      contents += yBtn
      contents += zBtn
      contents += scale
    }

    val group = new GridPanel(1,2) {
      contents += dataPanel
      contents += settingsLayout
    }


    /**
     *  The scala.swing.Component that visualizes the value.
     */
    //Todo: Implement yourself!
    val component = group

    /**
     *  This function is called whenever the visualized value changes.
     *  It should update component accordingly.
     */
    //Todo: Implement yourself!
    def update(sVarValue: ConstMat4f) {
      data = Some(sVarValue)
      dataPanel.repaint()
      //component.text = sVarValue.toString
    }

  }

  /**
   *  The name of this visualizer.
   *  This must not be unique.
   */
  //Todo: Name it!
  val name: String = "Axis Directions"

}